package main

import "fmt"

/*
팩토리 메소드 패턴 : 객체 생성 함수를 추상화하여 실제 객체 생성 로직을 은닉하는 방법.

팩토리 메소드 패턴은 만들고자 하는 객체(상품)와 객체를 생성하는 공장(팩토리)로 구성한다. 객체를 생성하는 공장은 팩토리 메소드를 선언한 인터페이스를 상속받아
구현하였으므로, 클라이언트는 공장의 내부를 알 필요 없이 팩토리 메소드를 통해 필요한 객체를 생성하면 된다. 이를 통해 객체의 생성과 클라이언트에서의 사용을 분리하여
새로운 객체가 필요한 경우 펙토리 메소드에 객체를 추가하거나, 새로운 팩토리를 생성하면 의존도를 낮추고 코드 수정량을 줄일 수 있다.

객체를 생성하는 메소드를 추상화 한다는 점에서 이를 팩토리 메소드 패턴이라 부르며, 이 점에 있어 객체를 모두 추상화 하는 추상 팩토리와 다르다.

대부분의 OOP 언어는 인터페이스나 추상클래스를 통해 팩토리 메소드를 구현할 수 있다. 하지만 GO 는 추상 구조체가 없으므로 함수포인터를 써서 "추상 구조체 처럼"
사용해야 한다. 그 전에 "추상 구조체" 가 필요한지 부터 파악하고, 불필요 하다면 인터페이스를 상속받는걸로 팩토리 메소드 패턴을 구현한다. 만약 팩토리 메소드를
호출 할 때 구상 팩토리 구조체의 팩토리 메소드 호출 외에 추가적인 공통로직 구현이 필요하다면 "추상 구조체"를, 아니면 인터페이스로 팩토리 메소드를 정의한다.

만약 "추상 구조체"를 써야 한다면 다음과 같이 구현한다.
- 추상 팩토리 구조체를 선언하면서 팩토리 메소드와 함수 포인터를 추가한다.
- 팩토리 구조체에 추상 팩토리 구조체를 임베딩 한다.
- 팩토리 구조체 생성자를 구현한다. 생성한 구조체의 함수 포인터에 팩토리 구조체의 팩토리 메소드를 연결한다.
- 추상 팩토리 구조체의 팩토리 메소드를 구현한다(단 함수명은 달라야 한다). 공통로직과 팩토리 메소드 함수 포인터를 호출한다.
- 클라이언트에서 팩토리 메소드를 직접 호출하거나, 인터페이스로 변환하여 호출한다.
*/
func main() {
	var factory Factory
	var product Product
	fmt.Println("--- Factory A ---")
	factory = NewFactoryA()
	product = factory.FactoryMethod("1")
	product.Describe()

	fmt.Println()
	fmt.Println("--- Factory B ---")
	factory = NewFactoryB()
	product = factory.FactoryMethod("Y")
	product.Describe()
}
